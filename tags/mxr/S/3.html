<html>
<head>
<title>kernel/arch/i386/boot/boot.s</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.5'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<a name='TOP'><h2><a href='../mains.html'>root</a>/<a href='../files/47.html'>kernel</a>/<a href='../files/48.html'>arch</a>/<a href='../files/49.html'>i386</a>/<a href='../files/50.html'>boot</a>/boot.s</h2>
<i><font color='green'>/* [&lt;][&gt;][^][v][top]<a href='#BOTTOM'>[bottom]</a><a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
<hr>
<pre>
<a name='L1'><i><font color='green'>/*****************************************************************************</font></i>
<a name='L2'><i><font color='green'> * Micron System V3 - I386 Boot &amp; Loader</font></i>
<a name='L3'><i><font color='green'> * Copyright (C) 2007, Micron System Team</font></i>
<a name='L4'><i><font color='green'> * Copyright (C) 2007, Martin Tang</font></i>
<a name='L5'><i><font color='green'> * PROTECTED UNDER MICRON SYSTEM PUBLIC LICENSE AGREEMENT.</font></i>
<a name='L6'><i><font color='green'> *****************************************************************************</font></i>
<a name='L7'><i><font color='green'> * Design Notes:</font></i>
<a name='L8'><i><font color='green'> *</font></i>
<a name='L9'><i><font color='green'> *   We try to make this as simple as possible.</font></i>
<a name='L10'><i><font color='green'> *</font></i>
<a name='L11'><i><font color='green'> *   First implement a basic kernel loading process, get info from super block</font></i>
<a name='L12'><i><font color='green'> *   then do the copy.</font></i>
<a name='L13'><i><font color='green'> *</font></i>
<a name='L14'><i><font color='green'> *   The identification of disk geometry is needed.</font></i>
<a name='L15'><i><font color='green'> *</font></i>
<a name='L16'><i><font color='green'> * Bootloader Memory Map:</font></i>
<a name='L17'><i><font color='green'> *</font></i>
<a name='L18'><i><font color='green'> *   As memtioned in BIOS global memory reference, the memory from range 0x500</font></i>
<a name='L19'><i><font color='green'> *   to 0xA0000 is avaliable for free use, our boot code loads through 0x7C00</font></i>
<a name='L20'><i><font color='green'> *   to 0x7E00, our kernel needs 512 kb of memory and also such size of buffer,</font></i>
<a name='L21'><i><font color='green'> *   so we concluded the following memory map:</font></i>
<a name='L22'><i><font color='green'> *</font></i>
<a name='L23'><i><font color='green'> *   0x07C00 ~ 0x07DFF = 512 byte : Bootloader</font></i>
<a name='L24'><i><font color='green'> *   0x0FFFF ~ 0x07E00 =  33 kb   : Bootloader stack (set by BIOS)</font></i>
<a name='L25'><i><font color='green'> *   0x10000 ~ 0x90000 = 512 kb   : Kernel image transfer buffer</font></i>
<a name='L26'><i><font color='green'> *   0x100000                     : Final destination of kernel image</font></i>
<a name='L27'><i><font color='green'> *</font></i>
<a name='L28'><i><font color='green'> * Hard Disk Geometry(BIOS CHS MODE ONLY):</font></i>
<a name='L29'><i><font color='green'> *</font></i>
<a name='L30'><i><font color='green'> *   Cylinder : 10 bits = 0 ~ 1023</font></i>
<a name='L31'><i><font color='green'> *   Head     :  8 bits = 0 ~  255</font></i>
<a name='L32'><i><font color='green'> *   Sector   :  6 bits = 1 ~   63</font></i>
<a name='L33'><i><font color='green'> *   Total    : 0x1F8000000 bytes</font></i>
<a name='L34'><i><font color='green'> *</font></i>
<a name='L35'><i><font color='green'> * Floppy Disk Geometry(Same as physical geometry):</font></i>
<a name='L36'><i><font color='green'> *</font></i>
<a name='L37'><i><font color='green'> *   Cylinder : 0 ~ 79</font></i>
<a name='L38'><i><font color='green'> *   Head     : 0 ~  1</font></i>
<a name='L39'><i><font color='green'> *   Sector   : 1 ~ 18</font></i>
<a name='L40'><i><font color='green'> *</font></i>
<a name='L41'><i><font color='green'> *   Total    : 0x168000 bytes</font></i>
<a name='L42'><i><font color='green'> *</font></i>
<a name='L43'><i><font color='green'> * MFS Hard Disk Data Map:</font></i>
<a name='L44'><i><font color='green'> *</font></i>
<a name='L45'><i><font color='green'> *   Block size: 1024 byte (2 sectors)</font></i>
<a name='L46'><i><font color='green'> *</font></i>
<a name='L47'><i><font color='green'> *   Block N : COUNT : TYPE</font></i>
<a name='L48'><i><font color='green'> *   Block 0 :     1 : boot block</font></i>
<a name='L49'><i><font color='green'> *   Block 1 :     1 : super block</font></i>
<a name='L50'><i><font color='green'> *   Block 2 :   512 : kernel block     ** count is registered in super block</font></i>
<a name='L51'><i><font color='green'> *   ...</font></i>
<a name='L52'><i><font color='green'> *</font></i>
<a name='L53'><i><font color='green'> * MFS Floppy Disk Data Map:</font></i>
<a name='L54'><i><font color='green'> *</font></i>
<a name='L55'><i><font color='green'> *   (Unspecified yet)</font></i>
<a name='L56'><i><font color='green'> *</font></i>
<a name='L57'><i><font color='green'> *****************************************************************************/</font></i>
<a name='L58'>.file "boot.s"
<a name='L59'>.text
<a name='L60'>
<a name='L61'><i><font color='green'>/* Tell the assembler that we are generating 16 bit code */</font></i>
<a name='L62'>.code16
<a name='L63'>
<a name='L64'><i><font color='green'>/* </font></i>
<a name='L65'><i><font color='green'> * This is our entry point, everything starts here</font></i>
<a name='L66'><i><font color='green'> * Buggy BIOSes should add initialization codes later</font></i>
<a name='L67'><i><font color='green'> */</font></i>
<a name='L68'>.global _start; _start:
<a name='L69'>        movb %dl, b_devi        <i><font color='green'>/* dl stores the boot device id */</font></i>
<a name='L70'>        test $0x80, %dl         <i><font color='green'>/* which is passed from BIOS */</font></i>
<a name='L71'>        jz  boot_fdd            <i><font color='green'>/* goto floppy disk startup */</font></i>
<a name='L72'>        jmp boot_hdd            <i><font color='green'>/* goto hard disk startup */</font></i>
<a name='L73'>        hlt
<a name='L74'>
<a name='L75'><i><font color='green'>/* Booted from floppy disk */</font></i>
<a name='L76'>boot_fdd:                       <i><font color='green'>/* TODO: Write floppy specified boot */</font></i>
<a name='L77'>        hlt                     <i><font color='green'>/*       there's no specification for */</font></i>
<a name='L78'>                                <i><font color='green'>/*       floppy in MFS now*/</font></i>
<a name='L79'>
<a name='L80'><i><font color='green'>/* Booted from hard disk */</font></i>
<a name='L81'>boot_hdd:               
<a name='L82'>        call stat_dev           <i><font color='green'>/* detect boot device attribute */</font></i>
<a name='L83'>        call stat_ksize         <i><font color='green'>/* get kernel storage info on dev */</font></i>
<a name='L84'>        call kern_copy          <i><font color='green'>/* copy kernel from disk to buffer */</font></i>
<a name='L85'>        jmp  entr_pm            <i><font color='green'>/* enter protected mode */</font></i>
<a name='L86'>        ret
<a name='L87'>
<a name='L88'><i><font color='green'>/* </font></i>
<a name='L89'><i><font color='green'> * Acquire the information about geometry of boot disk</font></i>
<a name='L90'><i><font color='green'> * should be fesiable for both floppy and hdd</font></i>
<a name='L91'><i><font color='green'> */</font></i>
<a name='L92'>stat_dev:
<a name='L93'>        movb $0x08, %ah         <i><font color='green'>/* function number */</font></i>
<a name='L94'>        movb b_devi,%dl         <i><font color='green'>/* drive number */</font></i>
<a name='L95'>        int  $0x13
<a name='L96'>        jc   error              <i><font color='green'>/* we don't want this to happen */</font></i>
<a name='L97'>        movb %bl,    b_devt     <i><font color='green'>/* store dev type if is floppy */</font></i>
<a name='L98'>        movb %ch,    b_devc     <i><font color='green'>/* low 8 bits of max cyl number */</font></i>
<a name='L99'>        movb %cl,    b_devs     <i><font color='green'>/* max sector number (bits 5-0) */</font></i>
<a name='L100'>        andb $0x3F,  b_devs
<a name='L101'>        andw $0xC0,  %cx        <i><font color='green'>/* get high 2 bits of max cyl number */</font></i>
<a name='L102'>        shlw $0x02,  %cx        <i><font color='green'>/* align it to position */</font></i>
<a name='L103'>        addw %cx,    b_devc     <i><font color='green'>/* add up to the cyl number data */</font></i>
<a name='L104'>        movb %dh,    b_devh     <i><font color='green'>/* max head number */</font></i>
<a name='L105'>        movb %dl,    b_devn     <i><font color='green'>/* number of drives */</font></i>
<a name='L106'>        movw b_devs, %ax        <i><font color='green'>/* calculate bytes per head */</font></i>
<a name='L107'>        movw $512,   %bx
<a name='L108'>        mulw %bx
<a name='L109'>        movw %ax,    b_sizh     <i><font color='green'>/* store size per head */</font></i>
<a name='L110'>        ret
<a name='L111'>
<a name='L112'>copy_c: .word 0
<a name='L113'>copy_h: .byte 0
<a name='L114'>copy_s: .byte 0
<a name='L115'>copy_n: .byte 0
<a name='L116'>copy_d: .word 0x1000
<a name='L117'>
<a name='L118'><i><font color='green'>/* Copy kernel from disk to buffer */</font></i>
<a name='L119'>kern_copy:
<a name='L120'>        movw  b_ksec,  %ax      <i><font color='green'>/* only for the first time */</font></i>
<a name='L121'>        movb  b_devs,  %bl
<a name='L122'>        subb  %al,     %bl
<a name='L123'>        movb  %bl,     copy_n
<a name='L124'>        movb  %al,     copy_s
<a name='L125'>1:      movb  b_devi,  %dl      <i><font color='green'>/* boot device i */</font></i>
<a name='L126'>        movb  copy_n,  %al      <i><font color='green'>/* sectors to transfer per time */</font></i>
<a name='L127'>        movw  copy_c,  %bx      <i><font color='green'>/* start cylinder number */</font></i>
<a name='L128'>        movb  copy_h,  %dh      <i><font color='green'>/* start head number */</font></i>
<a name='L129'>        movb  copy_s,  %cl      <i><font color='green'>/* start sector number */</font></i>
<a name='L130'>        addb  $1,      %cl
<a name='L131'>        push  copy_d
<a name='L132'>        pop   %es
<a name='L133'>        movw  $0,      %si      <i><font color='green'>/* beginning from 0x10000 */</font></i>
<a name='L134'>        call  copy_block
<a name='L135'>        movw  b_kcnt,  %ax
<a name='L136'>        subw  copy_n,  %ax
<a name='L137'>        js    3f
<a name='L138'>        movw  %ax,     b_kcnt
<a name='L139'>        movw  b_sizh,  %ax
<a name='L140'>        shrw  $4,      %ax
<a name='L141'>        addw  %ax,     copy_d
<a name='L142'>        movb  b_devs,  %al
<a name='L143'>        movb  %al,     copy_n
<a name='L144'>        movb  $0,      copy_s
<a name='L145'>        movb  copy_h,  %al
<a name='L146'>        incb  %al
<a name='L147'>        cmpb  b_devh,  %al
<a name='L148'>        jz    2f
<a name='L149'>        jmp   1b
<a name='L150'>2:      movw  copy_c,  %ax
<a name='L151'>        incw  %ax
<a name='L152'>        cmpw  b_devc,  %ax
<a name='L153'>        jz    error
<a name='L154'>        jmp   1b
<a name='L155'>3:      ret
<a name='L156'>
<a name='L157'><i><font color='green'>/* </font></i>
<a name='L158'><i><font color='green'> * Function to acquire kernel size to copy, result in sectors, store</font></i>
<a name='L159'><i><font color='green'> * to b_ksec and b_kcnt.</font></i>
<a name='L160'><i><font color='green'> */</font></i>
<a name='L161'>stat_ksize:
<a name='L162'>        movb $0x02,      %al    <i><font color='green'>/* read super block, 2 sectors */</font></i>
<a name='L163'>        movw $0x00,      %bx
<a name='L164'>        movb $0x00,      %dh
<a name='L165'>        movb $0x03,      %cl    <i><font color='green'>/* sector 3 */</font></i>
<a name='L166'>        movb b_devi,     %dl
<a name='L167'>        push %cs
<a name='L168'>        pop  %es
<a name='L169'>        movw $buf,       %si
<a name='L170'>        call copy_block
<a name='L171'>        movw %es:4(%bx), %ax    <i><font color='green'>/* s_kblk */</font></i>
<a name='L172'>        movw $0x02,      %cx    <i><font color='green'>/* 2 sectors per block in MFS */</font></i>
<a name='L173'>        mulw %cx
<a name='L174'>        movw %ax,        b_ksec
<a name='L175'>        movw %es:6(%bx), %ax    <i><font color='green'>/* s_kblkcnt */</font></i>
<a name='L176'>        movw $0x02,      %cx    <i><font color='green'>/* same as above */</font></i>
<a name='L177'>        mulw %cx
<a name='L178'>        movw %ax,        b_kcnt
<a name='L179'>        ret
<a name='L180'>
<a name='L181'><i><font color='green'>/* </font></i>
<a name='L182'><i><font color='green'> * Function to read specified CHS to dest memory</font></i>
<a name='L183'><i><font color='green'> * Specifications: </font></i>
<a name='L184'><i><font color='green'> *</font></i>
<a name='L185'><i><font color='green'> * Inputs:</font></i>
<a name='L186'><i><font color='green'> *</font></i>
<a name='L187'><i><font color='green'> *   AL    : Sectors to read</font></i>
<a name='L188'><i><font color='green'> *   BX    : Cylinder</font></i>
<a name='L189'><i><font color='green'> *   DH    : Head</font></i>
<a name='L190'><i><font color='green'> *   CL    : Sector</font></i>
<a name='L191'><i><font color='green'> *   DL    : Drive</font></i>
<a name='L192'><i><font color='green'> *   ES:SI : Destination</font></i>
<a name='L193'><i><font color='green'> */</font></i>
<a name='L194'>copy_block:
<a name='L195'>        mov   $0x02, %ah
<a name='L196'>        shlb  $0x06, %bh        <i><font color='green'>/* process high 2 bits of cylinder */</font></i>
<a name='L197'>        orb   %bh,   %cl
<a name='L198'>        movb  %bl,   %ch
<a name='L199'>        movw  %si,   %bx
<a name='L200'>        int   $0x13
<a name='L201'>        jc    error
<a name='L202'>        ret
<a name='L203'>        
<a name='L204'><i><font color='green'>/* Function to enter protected mode */</font></i>
<a name='L205'>entr_pm:
<a name='L206'>        cli                     <i><font color='green'>/* from here on, we disable interrupts */</font></i>
<a name='L207'>        lgdt b_gdtr             <i><font color='green'>/* load GDT register */</font></i>
<a name='L208'>        movl %cr0,  %eax        <i><font color='green'>/* enable protected mode */</font></i>
<a name='L209'>        orl  $0x01, %eax
<a name='L210'>        movl %eax,  %cr0
<a name='L211'>        movw $0x10, %ax         <i><font color='green'>/* setup value of various segments */</font></i>
<a name='L212'>        movw %ax,   %ds
<a name='L213'>        movw %ax,   %es
<a name='L214'>        movw %ax,   %fs
<a name='L215'>        movw %ax,   %gs
<a name='L216'>        movw %ax,   %ss
<a name='L217'>        ljmp $0x08, $_start32   <i><font color='green'>/* flush instruction pipe */</font></i>
<a name='L218'>
<a name='L219'><i><font color='green'>/* error handler */</font></i>
<a name='L220'>error:
<a name='L221'>        hlt                     <i><font color='green'>/* when error is met, just halt */</font></i>
<a name='L222'>
<a name='L223'><i><font color='green'>/* Tell the assembler that we are generating 32 bit code */</font></i>
<a name='L224'>.code32
<a name='L225'>
<a name='L226'><i><font color='green'>/* Entry point of 32 bit mode */</font></i>
<a name='L227'>_start32:
<a name='L228'>        call kern_move
<a name='L229'>        movb $'A', 0xb8000
<a name='L230'>        ljmp $0x08, $0x100000   <i><font color='green'>/* jump to kernel entry point */</font></i>
<a name='L231'>                                <i><font color='green'>/* this is the point of no return */</font></i>
<a name='L232'>
<a name='L233'><i><font color='green'>/* Kernel Loader */</font></i>
<a name='L234'>kern_move:
<a name='L235'>        movl $0x10000,  %esi
<a name='L236'>        movl $0x100000, %edi
<a name='L237'>1:      movl (%esi),    %eax
<a name='L238'>        movl %eax,      (%edi)
<a name='L239'>        cmpl $0x90000,  %esi
<a name='L240'>        jz   2f
<a name='L241'>        addl $0x04,     %esi
<a name='L242'>        addl $0x04,     %edi
<a name='L243'>        jmp  1b
<a name='L244'>2:      ret
<a name='L245'>
<a name='L246'><i><font color='green'>/* Boot up information storage */</font></i>
<a name='L247'>.global b_devi, b_devt, b_devn, b_devc, b_devh, b_devs, b_ksec, b_kcnt
<a name='L248'>b_devi: .byte 0                 <i><font color='green'>/* boot device indicator */</font></i>
<a name='L249'>b_devt: .byte 0                 <i><font color='green'>/* boot device type for floppy only */</font></i>
<a name='L250'>b_devn: .byte 0                 <i><font color='green'>/* number of drives */</font></i>
<a name='L251'>b_devc: .word 0                 <i><font color='green'>/* boot device cylinder number */</font></i>
<a name='L252'>b_devh: .byte 0                 <i><font color='green'>/* boot device head number */</font></i>
<a name='L253'>b_devs: .byte 0                 <i><font color='green'>/* boot device sector number */</font></i>
<a name='L254'>b_sizh: .word 0                 <i><font color='green'>/* bytes per head */</font></i>
<a name='L255'>b_ksec: .long 0                 <i><font color='green'>/* kernel beginning sector */</font></i>
<a name='L256'>b_kcnt: .long 0                 <i><font color='green'>/* kernel size in sector(s) */</font></i>
<a name='L257'>
<a name='L258'><i><font color='green'>/* Boot up temporary GDT, abandoned by kernel */</font></i>
<a name='L259'>b_gdt:
<a name='L260'>
<a name='L261'><i><font color='green'>/* Null entry */</font></i>
<a name='L262'>.long 0
<a name='L263'>.long 0
<a name='L264'>
<a name='L265'><i><font color='green'>/* 0x08 code segment */</font></i>
<a name='L266'>.word 0xFFFF                    <i><font color='green'>/* limit 0..15 */</font></i>
<a name='L267'>.word 0x0000                    <i><font color='green'>/* base  0..15 */</font></i>
<a name='L268'>.byte 0x00                      <i><font color='green'>/* base 16..23 */</font></i>
<a name='L269'>.byte 0x9E                      <i><font color='green'>/* P=1, DPL=0, code, Conforming, Read */</font></i>
<a name='L270'>.byte 0xCF                      <i><font color='green'>/* 4 kb, 32bit code, limit 16..19=1111B */</font></i>
<a name='L271'>.byte 0x00                      <i><font color='green'>/* base 24..31=00H */</font></i>
<a name='L272'>
<a name='L273'><i><font color='green'>/* 0x10 data segment */</font></i>
<a name='L274'>.word 0xFFFF                    <i><font color='green'>/* limit 0..15 */</font></i>
<a name='L275'>.word 0x0000                    <i><font color='green'>/* base  0..15 */</font></i>
<a name='L276'>.byte 0x00                      <i><font color='green'>/* base 16..23 */</font></i>
<a name='L277'>.byte 0x92                      <i><font color='green'>/* P=1, DPL=0, data, Read/Write */</font></i>
<a name='L278'>.byte 0xCF                      <i><font color='green'>/* 4 kb, 32bit stack, limit 16..19=1111B */</font></i>
<a name='L279'>.byte 0x00                      <i><font color='green'>/* base 24..31=00H */</font></i>
<a name='L280'>
<a name='L281'><i><font color='green'>/* GDT Register data */</font></i>
<a name='L282'>b_gdtr:
<a name='L283'>.value b_gdtr - b_gdt -1
<a name='L284'>.long  b_gdt
<a name='L285'>
<a name='L286'><i><font color='green'>/* Write our boot signature here so that BIOS can recongnize */</font></i>
<a name='L287'>.org  510
<a name='L288'>.word 0xaa55
<a name='L289'>buf:                            <i><font color='green'>/* Temporary buffer for reading super blk */</font></i>
<a name='L290'>
</pre>
<hr>
<a name='BOTTOM'>
<i><font color='green'>/* [&lt;][&gt;][^][v]<a href='#TOP'>[top]</a>[bottom]<a href='../mains.html'>[index]</a><a href='../help.html'>[help]</a> */</font></i>
</body>
</html>
